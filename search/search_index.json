{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#embedded-programming-tutorials","title":"Embedded Programming - Tutorials","text":""},{"location":"#objectives","title":"Objectives","text":"<p>Here you will find a set of tutorials to practice the Embedded Programming concepts using the ESP32 and the Arduino IDE.</p> <p></p> <p>This repository is intended to facilitate the understanding of the concepts presented in class, providing step-by-step examples, exercises, and references that students can reproduce and expand upon independently. By following the tutorials, you will gradually build the skills necessary to work with embedded systems in a structured and practical way.</p> <p>This page is available at: https://github.com/costawess/EmbeddedProgramming-Course/</p>"},{"location":"#ep-content","title":"EP Content","text":"<p>The content of each tutorial is listed below:</p> <ul> <li>Workshop 1 - Setting up the Arduino IDE. Hello World.</li> <li>Workshop 2 - Flowcharts, if-else, while.</li> <li>Workshop 3 - Variables, Data types, If and Loops.</li> <li>Workshop 4 - UART and ADC.</li> <li>Workshop 5 - Functions, Libraries, Interrupts, Timers</li> <li>Workshop 6 - Kitchen Timer.</li> <li>Workshop 7 - I2C protocol and State Machine.</li> </ul>"},{"location":"#extra-tutorials","title":"Extra Tutorials","text":"<p>\u26a0\ufe0f This section is still in progress.</p>"},{"location":"#how-to-use","title":"How to use","text":""},{"location":"#organization","title":"Organization","text":"<p>The tutorials are presented in sequence, starting from the simplest concepts and gradually moving to more complex and broader topics. Each concept is introduced step by step, followed by clear examples that can be reproduced directly. Students are encouraged to modify the provided code and apply it to other small projects, reinforcing understanding and solidifying knowledge through experimentation.</p>"},{"location":"#compatibility","title":"Compatibility","text":"<p>All code examples have been developed and tested using Arduino IDE version 2.3.5. The reference hardware used throughout this repository is the ESP32-WROOM-1 development board. While most sketches should work on other ESP32 variants, minor adjustments may be required (e.g., pin mappings).</p>"},{"location":"#external-links","title":"External links","text":"<ul> <li>ESP32-WROOM-32: Datasheet Version 3.6 - https://www.espressif.com/sites/default/files/documentation/esp32-wroom-32_datasheet_en.pdf</li> </ul>"},{"location":"tutorials/tutorial1/ReadMe/","title":"Workshop 1 - Setting up the Integrated Development Environment","text":""},{"location":"tutorials/tutorial1/ReadMe/#what-is-the-arduino-software-ide","title":"What is the Arduino Software (IDE)?","text":"<p>The Arduino Integrated Development Environment\u2014or Arduino Software (IDE)\u2014connects to Arduino/ESP boards to upload software and communicate with them. It brings together in a single graphical interface essential tools for software development, such as a code editor, compiler, and debugger.</p> <p>The programs, also called sketches, are writen in the code editor and save as a <code>.ino</code> file.</p>"},{"location":"tutorials/tutorial1/ReadMe/#download-the-ide","title":"Download the IDE","text":"<p>First things first: Download the Arduino IDE on the official website Arduino.cc.</p>"},{"location":"tutorials/tutorial1/ReadMe/#connect-the-esp32-and-install-the-driver","title":"Connect the ESP32 and Install the Driver","text":"<p>To establish a serial connection with your ESP32 device, use a USB-to-UART bridge. This allows your computer to communicate with the ESP32 for programming and debugging.</p> <p></p> <p>In some cases, the USB-to-UART bridge is provided as an external module. This approach is common for compact development boards or final products where minimizing space and cost is important.</p> <p></p> <ul> <li>The chip enables bidirectional communication (conversion):<ul> <li>from the ESP, it converts UART to USB for the PC.</li> <li>from the PC, it converts USB to UART for the ESP.</li> </ul> </li> <li>So what is the purpose of the driver?<ul> <li>it allows the operating system to recognize this chip as a virtual serial port (<code>COM</code>).</li> </ul> </li> </ul> <p>That is what we will do! ;)</p> <ol> <li>First connect the ESP32 to the PC.</li> <li>Download and install the CP210x driver: CP210x USB to UART Bridge VCP Drivers.</li> <li>Check whether the installation was successful. In the Device Manager, under \"Ports,\" the <code>Silicon Labs CP210x USB to UART</code> should appear.</li> </ol> <p></p> <p>For more details, refer to the ESP32 Serial Connection Guide.</p>"},{"location":"tutorials/tutorial1/ReadMe/#ide-at-first-glance","title":"IDE at First Glance","text":"<p>When you open the IDE for the first time, this sketch window appears.</p> <p></p> <ul> <li> <p><code>void setup()</code>: runs only once. Used for initialisations.</p> </li> <li> <p><code>void loop()</code>: runs in a loop. Statements are executed infinitely.</p> </li> </ul> <p>In summary, this is the basic structure that every Arduino program follows. The <code>setup()</code> function runs once at the start, typically used for initialization, while the <code>loop()</code> function contains the main code that runs repeatedly. This structure ensures your program can continuously respond to inputs and perform tasks.</p> <pre><code>// this is a comment\n\nvoid setup()\n{\n    //this part will be run just once\n}\n\nvoid loop()\n{\n    //this part will be executed in a loop\n    //(as the name of the function suggests)\n}\n</code></pre> <p>The following flowchart represents the code flow.</p> <p></p>"},{"location":"tutorials/tutorial1/ReadMe/#installing-the-esp32-library","title":"Installing the ESP32 library","text":"<p>Navigate to the Boards Manager, search for <code>Arduino ESP32 Boards</code> or <code>esp32</code>, and then click <code>Install</code>.</p> <p></p> <p>If this step did not work, please follow the randomNerdsTutorial approach link to install the ESP32 board in the arduino IDE. </p>"},{"location":"tutorials/tutorial1/ReadMe/#selecting-the-esp-board","title":"Selecting the ESP board","text":"<p>To select the board navigate to <code>Tools &gt; Board &gt; esp32 &gt; ESP32 Dev Module</code>.</p> <p></p> <p>Alternativelly:</p> <p></p>"},{"location":"tutorials/tutorial1/ReadMe/#example-1-hello-world","title":"Example 1: Hello World","text":"<p>The codes below show two options for printing \"Hello World\" via Serial communication. Please open the Serial Monitor in the Arduino IDE to see what is being transmitted.</p> <pre><code>// ESP32 \"Hello, world\" \u2014 v1\nvoid setup() {\n  Serial.begin(115200);          // Open serial at 115200 bps\n  Serial.println(\"Hello, world\"); \n}\n\nvoid loop() {\n  // Nothing to do here\n}\n</code></pre> <pre><code>// ESP32 \"Hello, world\" \u2014 v2\nvoid setup() {\n  Serial.begin(115200);\n}\n\nvoid loop() {\n  Serial.println(\"Hello, world\");\n  delay(1000);\n}\n</code></pre> <p>Question: What is the difference in the behavior of the codes?</p> <ul> <li>In the first code, \"Hello, world\" is printed only once, right after the ESP32 starts, because the <code>Serial.println(\"Hello, world\");</code> command is inside the <code>setup()</code> function, which runs only once.</li> <li>In the second code, \"Hello, world\" is printed repeatedly every second, because the <code>Serial.println(\"Hello, world\");</code> command is inside the <code>loop()</code> function, which runs continuously. The <code>delay(1000);</code> causes a 1-second pause between each print.</li> </ul>"},{"location":"tutorials/tutorial1/ReadMe/#example-2-wifi-scan","title":"Example 2: Wifi Scan","text":"<p>Let's try a built-in example from the IDE.</p> <p>First, open the WiFiScan example. Navigate to <code>File &gt; Examples &gt; WiFi &gt; WiFiScan</code>.</p> <p></p> <p>To open the Serial Monitor, click the magnifying glass icon in the upper right corner of the window.</p> <p></p> <p>The ESP will output the Wifi networks found:</p> <p></p>"},{"location":"tutorials/tutorial1/ReadMe/#references","title":"References","text":"<ul> <li>Using the Arduino Software (IDE) https://docs.arduino.cc/learn/starting-guide/the-arduino-software-ide/</li> <li>UART Communication https://randomnerdtutorials.com/esp32-uart-communication-serial-arduino/</li> </ul>"},{"location":"tutorials/tutorial1/ReadMe/#input-and-output","title":"Input and Output","text":""},{"location":"tutorials/tutorial1/ReadMe/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand the concept of GPIO (General Purpose Input/Output).</li> <li>Configure ESP32 digital pins as input and output.</li> <li>Write simple programs to control LEDs.</li> <li>Read the state of physical buttons and use them to interact with LEDs.</li> <li>Develop basic conditional control logic using if/else statements.</li> </ul>"},{"location":"tutorials/tutorial1/ReadMe/#introduction-to-gpios","title":"Introduction to GPIOs","text":""},{"location":"tutorials/tutorial1/ReadMe/#what-are-digital-input-and-output-pins","title":"What are digital input and output pins?","text":"<ul> <li> <p>Digital Output:     A pin configured as output can send a HIGH (3.3V) or LOW (0V) signal. Then powering an LED for instance.     Example: turning an LED on or off.  </p> </li> <li> <p>Digital Input:     A pin configured as input can read external signals as HIGH or LOW. Example: checking if a button is pressed.</p> </li> </ul> <p>Important to note that in many microcontrollers, every GPIO is at least digital. Some GPIOs have extra capabilities, such as analog input, PWM, or special functions such as connectivity protocols. For the ESP32-WROOM-32, please refer to the \"Pin Definitions\" chapter in the datasheet.</p>"},{"location":"tutorials/tutorial1/ReadMe/#basic-configuration-in-code","title":"Basic configuration in code","text":""},{"location":"tutorials/tutorial1/ReadMe/#output-examples-leds","title":"Output Examples \u2013 LEDs","text":""},{"location":"tutorials/tutorial1/ReadMe/#turning-a-single-led-on-and-off","title":"Turning a single LED on and off","text":"<pre><code>// Turn on an LED using ESP32\n\n// Define the pin where the LED is connected\nconst int ledPin = 23;\n\nvoid setup() {\n  // Initialize the LED pin as an output\n  pinMode(ledPin, OUTPUT);\n\n  // Turn the LED on\n  digitalWrite(ledPin, HIGH);\n}\n\nvoid loop() {\n  // Nothing else to do in the loop since the LED remains on\n}\n</code></pre> <ul> <li><code>const int</code>: Declares the variable (<code>ledPin</code>) as a constant integer.</li> <li><code>pinMode</code>: Initializes the pin as <code>INPUT</code> or <code>OUTPUT</code>. This allows the pin to send/write voltage to the LED (OUTPUT) or to receive/read (INPUT).</li> <li><code>digitalWrite</code>: Sets the output of the pin to <code>HIGH</code> or <code>LOW</code>.</li> </ul> Exercise 1  **Task:**   Develop a program to light up multiple LEDs.  **Solution:**   [ex1](ex1/ex1.ino)  Exercise 2  **Task:**   Develop a program to light up multiple LEDs. Make them blink in sequence (use the `delay()` function).    **Solution:**   [ex2](ex2/ex2.ino)"},{"location":"tutorials/tutorial1/ReadMe/#input-examples-buttons","title":"Input Examples \u2013 Buttons","text":"<pre><code>// Reading the state of a button with ESP32\n\nconst int buttonPin = 34;  // GPIO where the button is connected\nint buttonState = 0; // state of the button\n\nvoid setup() {\n  // Initialize Serial Monitor\n  Serial.begin(115200);\n\n  // Configure the button pin as input\n  pinMode(buttonPin, INPUT);\n}\n\nvoid loop() {\n  // Read the state of the button\n  buttonState = digitalRead(buttonPin);\n\n  // Print the state\n  if (buttonState == HIGH) {\n    Serial.println(\"Button is pressed!\");\n  } else {\n    Serial.println(\"Button is not pressed.\");\n  }\n}\n</code></pre> Exercise 3  **Task:**   Develop a program to turn on an LED when the button is pressed.   Exercise 4  **Task:**   Develop a program to turn on an LED combinations: multiple buttons controlling LEDs. Create your own logic."},{"location":"tutorials/tutorial1/ReadMe/#next-workshop","title":"Next Workshop","text":"<p>Go to Workshop 2 - If-else, While, and Flowcharts.</p>"},{"location":"tutorials/tutorial2/ReadMe/","title":"Workshop 2 - If-else, While, and Flowcharts","text":""},{"location":"tutorials/tutorial2/ReadMe/#if-statement","title":"if statement","text":"<pre><code>int x = 10;\nint y = 20;\nif (x &gt; y) {\n  printf(\"x is greater than y\"); // msg\n}\n</code></pre>"},{"location":"tutorials/tutorial2/ReadMe/#if-else-statement","title":"if-else statement","text":"<pre><code>int x = 10;\nint y = 20;\nif (x &gt; y) {\n  printf(\"x is greater than y\"); //msg1\n}\nelse\n{\n    printf(\"x is greater than y\"); //msg2\n}\n</code></pre>"},{"location":"tutorials/tutorial2/ReadMe/#if-else-if-statement","title":"if-else-if statement","text":"<pre><code>int x = 10;\n\nif (x &lt; 0) {\n  printf(\"x is less than 0\"); // message 1\n}\nelse if (x&lt;10)\n{\n    printf(\"x is greater than or equal to 0 and less than 10\"); // message 2\n}\nelse\n{\n    printf(\"x is greater than or equal to 10\"); // message 3\n}\n</code></pre>"},{"location":"tutorials/tutorial2/ReadMe/#the-switch-statement","title":"The switch statement","text":"<p>Instead of using many <code>if..else</code> statements, one can use the <code>switch</code> statement. The <code>switch</code> statement selects one of the code blocks to be executed according to an specific condition/expression:</p> <pre><code>switch (condition_or_expression) {\n  case Case1:\n    // code block 1\n    break;\n  case Case2:\n    // code block 2\n    break;\n  case Case3:\n    // code block 3\n    break;\n  default:\n    // default code\n}\n</code></pre> <p></p>"},{"location":"tutorials/tutorial2/ReadMe/#example-switch-statement","title":"Example: Switch statement","text":"<pre><code>int day = 3;\n\nswitch (day) {\n  case 6:\n    printf(\"Today is Saturday\");\n    break;\n  case 7:\n    printf(\"Today is Sunday\");\n    break;\n  default:\n    printf(\"Weekday! ;)\");\n}\n</code></pre> <ul> <li>Obs.: <code>break</code> exits the switch. If the command is omitted, the execution falls through into the next case. For more details refer to w3schools.</li> </ul>"},{"location":"tutorials/tutorial2/ReadMe/#while","title":"While","text":"<p>Example</p> <pre><code>char country[] = \"Netherlands\";\nint i = 0;\n\nvoid setup() {\n  // put your setup code here, to run once:\n  Serial.begin(115200);  \n\n  while(i&lt;11){\n    Serial.printf(\"%c\", country[i]);\n    Serial.println(country[i]);\n    i++; // variable = variable+1; variable++;\n  }\n}\n\nvoid loop() {\n}\n</code></pre>"},{"location":"tutorials/tutorial2/ReadMe/#next-tutorial","title":"Next Tutorial","text":"<p>Go to Workshop 3 - Variables, Data types, If and Loops.</p>"},{"location":"tutorials/tutorial3/ReadMe/","title":"Workshop 3 - Variables, Data types, If and Loops","text":""},{"location":"tutorials/tutorial3/ReadMe/#variables","title":"Variables","text":"<p>\u26a0\ufe0f This section is still in progress.</p>"},{"location":"tutorials/tutorial3/ReadMe/#variable-types","title":"Variable Types","text":"<p>This table shows the variable types commonly used in Arduino C, their memory size, and value ranges. Note: sizes and ranges depend on the board architecture (8-bit AVR vs 32-bit ESP32/ARM).</p> Type (C/Arduino) Bytes (AVR 8-bit) Range (AVR 8-bit) Bytes (ESP32/ARM 32-bit) Range (ESP32/ARM 32-bit) <code>bool</code> / <code>boolean</code> 1 <code>false</code> / <code>true</code> 1 <code>false</code> / <code>true</code> <code>char</code> (signed) 1 \u2212128 to 127 1 \u2212128 to 127 <code>unsigned char</code> / <code>byte</code> 1 0 to 255 1 0 to 255 <code>short</code> 2 \u221232,768 to 32,767 2 \u221232,768 to 32,767 <code>unsigned short</code> 2 0 to 65,535 2 0 to 65,535 <code>int</code> 2 \u221232,768 to 32,767 4 \u22122,147,483,648 to 2,147,483,647 <code>unsigned int</code> 2 0 to 65,535 4 0 to 4,294,967,295 <code>long</code> 4 \u22122,147,483,648 to 2,147,483,647 4 \u22122,147,483,648 to 2,147,483,647 <code>unsigned long</code> 4 0 to 4,294,967,295 4 0 to 4,294,967,295 <code>long long</code> 8 \u22129,223,372,036,854,775,808 to 9,223,372,036,854,775,807 8 same <code>unsigned long long</code> 8 0 to 18,446,744,073,709,551,615 8 same <code>float</code> 4 ~\u00b13.4\u00d710^38 (\u22486\u20137 digits precision) 4 ~\u00b13.4\u00d710^38 (\u22486\u20137 digits precision) <code>double</code> 4 (same as float) ~\u00b13.4\u00d710^38 (\u22486\u20137 digits precision) 8 ~\u00b11.7\u00d710^308 (\u224815\u201316 digits precision) <code>size_t</code> 2 0 to 65,535 4 0 to 4,294,967,295"},{"location":"tutorials/tutorial3/ReadMe/#notes","title":"Notes","text":"<ul> <li>Ranges assume two\u2019s-complement integers and IEEE-754 floating-point representation.</li> <li>On AVR boards (e.g., Arduino Uno, Nano), <code>double</code> is the same as <code>float</code> (32-bit).</li> <li>On ESP32/ARM boards, <code>double</code> is 64-bit.</li> <li><code>byte</code> is simply an alias for <code>unsigned char</code>.</li> </ul>"},{"location":"tutorials/tutorial3/ReadMe/#types-of-variables","title":"Types of Variables","text":""},{"location":"tutorials/tutorial3/ReadMe/#assigning-a-value-to-a-variable","title":"Assigning a value to a variable","text":"<p>\u26a0\ufe0f This section is still in progress.</p>"},{"location":"tutorials/tutorial3/ReadMe/#exercise","title":"Exercise","text":"<p>\u26a0\ufe0f This section is still in progress.</p>"},{"location":"tutorials/tutorial3/ReadMe/#next-tutorial","title":"Next Tutorial","text":"<p>Go to Workshop 4 - UART and ADC.</p>"},{"location":"tutorials/tutorial4/ReadMe/","title":"Workshop 4 - UART and ADC","text":""},{"location":"tutorials/tutorial4/ReadMe/#output","title":"OUTPUT","text":""},{"location":"tutorials/tutorial4/ReadMe/#input","title":"INPUT","text":""},{"location":"tutorials/tutorial4/ReadMe/#example-user-inputs-through-uart-comm","title":"Example: User inputs Through UART comm","text":"<pre><code>void setup() {\n  Serial.begin(115200);\n  Serial.println(\"Enter a number and press Enter:\");\n}\n\nvoid loop() {\n  if (Serial.available() &gt; 0) { // only starts if the serial communication is active\n    int value = Serial.parseInt();   // read an integer number from serial\n    Serial.print(\"You entered: \");\n    Serial.println(value);\n\n    if (value &gt; 5) {\n      Serial.println(\"The entered value is greater than 5\");\n    } else if (value &lt; 5) {\n      Serial.println(\"The entered value is less than 5\");\n    } else {\n      Serial.println(\"The entered value is equal to 5\");\n    }\n    Serial.println(\"\\nEnter another number:\");\n  }\n}\n</code></pre>"},{"location":"tutorials/tutorial4/ReadMe/#next-tutorial","title":"Next Tutorial","text":"<p>Go to Workshop 5 - Functions, Libraries, Interrupts, Timers.</p>"},{"location":"tutorials/tutorial5/ReadMe/","title":"Workshop 5 -  Functions, Libraries, Interrupts, Timers","text":"<p>\u26a0\ufe0f This section is still in progress.</p>"},{"location":"tutorials/tutorial5/ReadMe/#functions","title":"Functions","text":"<p>\u26a0\ufe0f This section is still in progress.</p>"},{"location":"tutorials/tutorial5/ReadMe/#libraries","title":"Libraries","text":"<p>\u26a0\ufe0f This section is still in progress.</p>"},{"location":"tutorials/tutorial5/ReadMe/#interrupts","title":"Interrupts","text":""},{"location":"tutorials/tutorial5/ReadMe/#hardware-interrupts","title":"Hardware Interrupts","text":""},{"location":"tutorials/tutorial5/ReadMe/#what-is-a-hardware-interrupt","title":"What is a Hardware Interrupt?","text":"<p>\u26a0\ufe0f This section is still in progress.</p>"},{"location":"tutorials/tutorial5/ReadMe/#software-interrupts-timers","title":"Software Interrupts - Timers","text":"<p>This tutorial demonstrates how to use hardware timer interrupts on the ESP32 using the Arduino framework. Timer interrupts allow you to execute specific code automatically at fixed time intervals, without blocking the main loop.</p>"},{"location":"tutorials/tutorial5/ReadMe/#what-is-a-timer-interrupt","title":"What is a Timer Interrupt?","text":"<p>A timer interrupt is a hardware-based mechanism that triggers a function (called an Interrupt Service Routine \u2013 ISR) after a specified time period. Unlike using the delay function <code>delay()</code>, timers operate independently of your main program flow, allowing for precise timing and non-blocking execution. The ESP32 has 4 hardware timers per group, allowing multiple independent timing operations.</p>"},{"location":"tutorials/tutorial5/ReadMe/#structure-overview","title":"Structure Overview","text":"<p>The general structure for using a timer interrupt on ESP32 is:</p> <pre><code>hw_timer_t *My_timer = NULL;  // timer object\n\n// Initialize timer interrupt\nMy_timer = timerBegin(0, 80, true);                 // timer index, prescaler, count up\ntimerAttachInterrupt(My_timer, &amp;onTimer, true);     // attach timer to ISR\ntimerAlarmWrite(My_timer, 1000000, true);           // set alarm to 1 second (in microseconds)\ntimerAlarmEnable(My_timer);                         // enable the alarm\n</code></pre>"},{"location":"tutorials/tutorial5/ReadMe/#example","title":"Example","text":"<p>The following code blinks the LED every two seconds.</p> <pre><code>//Embedded Programming\n\nint LED = 22;\n\nint ticks           = 20'000;\nint timer_frequency = 10'000;\n\nhw_timer_t *My_timer = NULL;        // timer object\n\nvoid IRAM_ATTR TimerInterrupt()\n{\n    digitalWrite(LED, !digitalRead(LED)); // The LED state is toggled each time the interrupt occurs.\n}\n\nvoid setup()\n{\n    pinMode(LED , OUTPUT);\n    // initialize timer interrupt\n    My_timer = timerBegin(timer_frequency);                     // clock frequency of the timer\n    timerAlarm(My_timer , ticks, true, 0);        // timer object name, value to generate interrupt, true = auto reload, number of reloads (0 = infinite)\n    timerAttachInterrupt(My_timer, &amp;TimerInterrupt);  // attach interrupt to timer\n    timerStart(My_timer);                              // stop tim\n}\n\nvoid loop()\n{\n    // Do Nothing!\n}\n</code></pre>"},{"location":"tutorials/tutorial5/ReadMe/#explanation","title":"Explanation","text":"<ul> <li><code>int ticks = 10000;</code>: this variable defines the number of ticks (count of the timer clock) before the timer interrupt is triggered. The total time (also called period) before the interrupt occurs is:</li> </ul> <p>[ T_\\text{interrupt} = \\frac{\\text{ticks}}{\\text{\\text{timer_frequency}}} = \\frac{20000}{10000} = 2~\\text{seconds} ]</p> <p>This means that the interrupt occurs every 2 seconds.</p> <ul> <li><code>hw_timer_t *My_timer = NULL;</code>: Creates a pointer to a hardware timer object. That means each tick = 1 / 10,000 = 0.0001 seconds = 100 \u00b5s.</li> <li><code>timerBegin(timer_frequency);</code>: Initializes the timer (in Hertz). In the example, the argument <code>timer_frequency</code> represents the base clock frequency (in this case <code>timer_frequency</code> = 10 kHz = 10 thousand ticks per second).</li> <li>A little bit of math: This means that each tick = 1 / 10,000 = 0.0001 seconds or 100 $\\mu$s.</li> <li><code>timerAttachInterrupt(My_timer, &amp;TimerInterrupt);</code>: Links the Interrupt Service Routine (ISR) to the timer. Which means that every time the timer reaches the tick count, it calls the function <code>TimerInterrupt()</code> (you can change the function as you wish). In the example, the function <code>TimerInterrupt()</code> is called every 2 seconds.</li> <li><code>timerAlarm(My_timer, ticks, true, 0);</code>: Configures when the timer should trigger an interrupt.</li> </ul> Parameter Value in the example Meaning timer object <code>My_timer</code> The timer object created earlier alarm value <code>ticks</code> Number of counts before triggering (in the example, 10,000) auto-reload <code>true</code> Auto-reload enabled (the timer repeats infinitely) reload count <code>0</code> Number of reloads (0 = infinite) <ul> <li><code>timerStart(My_timer);</code>: Starts the timer.</li> <li>Another timer functions:</li> </ul> Function Description <code>timerStart(My_timer)</code> Starts the timer <code>timerStop(My_timer)</code> Stops the timer <code>timerRestart(My_timer)</code> Restarts the timer <code>timerAlarmDisable(My_timer)</code> Disables the interrupt temporarily Exercise  ---  1. What should the tick values be for a timer with a frequency of 25kHz and a period ($T_\\text{interrupt}$) of:  a) 1 s; b) 10 s; c) 25 s; d) 25 ms;   Solution  a) ticks = $25000\\times 1 = 25000$ ticks b) ticks = $25000\\times 10 = 250000$ ticks c) ticks = $25000\\times 25 = 625000$ ticks d) ticks = $25000\\times 25\\times 10^{-3} = 25$ ticks    ---  2. Implement a code with two timers.  Solution  [Code](ws5_2_interrupts_timers_2timers/ws5_2_interrupts_timers_2timers.ino)    ---"},{"location":"tutorials/tutorial5/ReadMe/#next-tutorial","title":"Next Tutorial","text":"<p>Go to Workshop 6 - Kitchen Timer.</p>"},{"location":"tutorials/tutorial6/ReadMe/","title":"Workshop 6 - Kitchen Timer","text":"<p>\u26a0\ufe0f This section is still in progress.</p>"},{"location":"tutorials/tutorial6/ReadMe/#next-tutorial","title":"Next Tutorial","text":"<p>Go to Workshop 7 - I2C protocol and State Machine.</p>"},{"location":"tutorials/tutorial7/ReadMe/","title":"Workshop 7 - I2C protocol and State Machine","text":"<p>\u26a0\ufe0f This section is still in progress.</p>"}]}